\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{braket}
\usepackage{amsmath}

\title{Quantum Computing}
\author{tylertracy1999 }

\begin{document}

\maketitle

Classical Computers use classical bits.

Quantum computers use qubits which can be any value between 0 and 1. But when you measure it, it becomes either 0 or 1.

Qubits can interfere with each other to create a bigger probability distribution of states.

Quantum computers are much better at simulating quantum systems because they use real quantum objects to do the simulations. Where classical computers have to simulate quantum objects.

Another example of nature solving something quicker than a classical computer is how soap bubbles minimize surface area. A classical computer would take a couple of seconds to minimize the surface area of a shape while a real world soap bubble does it instantly.



Qubit Value
$$ \ket{\Psi} = a \ket{0} + b \ket{1} $$

The probability of a given value is equal to the squared magnitude of the coefficient (when the coefficients are normalized)

\section{Quantum Gates}

The X gate flips a qbit if the bit is known

The H gate makes a super position of all possible states, and converts a superposition of possible states into a single value. It converts a deterministic value into a probabilistic value and vice versa.

\section{Quantum Algorithms}

Shores Algorithm factors numbers on a quantum computer.

The best classical algorithm for factoring is $O(2^\frac{n}{2})$.
Shores algorithm is $O(log(n))$

Grovers algorithm can search unstructured data in $O(\sqrt(n))$

Quantum computers are computationally equivalent to classical computers. They still can't solve the haulting problem.




\section{Quantum Gates}





\end{document}